<h1>
رفرنس های تمپلیت:
</h1>

<div dir="rtl">
 در حالی که مدل رندر اعلامی Vue اکثر عملیات DOM مستقیم را برای شما انتزاعی می کند، ممکن است هنوز مواردی وجود داشته باشد که نیاز به دسترسی مستقیم به عناصر DOM اساسی داشته باشیم. برای رسیدن به این هدف، می توانیم از ویژگی ref ویژه استفاده کنیم:
</div>


```vue
<input ref="input" />
```

این ref یک ویژگی خاص است، شبیه به ویژگی کلیدی که در فصل v-for بحث شد. این به ما اجازه می دهد تا پس از نصب یک عنصر DOM خاص یا نمونه فرزند، یک رفرنس مستقیم به دست آوریم. این ممکن است زمانی مفید باشد که می‌خواهید، به عنوان مثال، یک ورودی را به صورت برنامه‌ریزی شده بر روی مقدار یک کامپوننت متمرکز کنید یا یک کتابخانه شخص ثالث را روی یک عنصر مقداردهی کنید.

<h2>
دسترسی به رفرنس ها با this.ref :
</h2>

```vue
<template>
  <input ref="input" />
</template>

<script>
export default {
  mounted() {
    this.$refs.input.focus()
  }
}
</script>

```

توجه داشته باشید که فقط پس از نصب کامپوننت می توانید به ref دسترسی داشته باشید. اگر سعی کنید به $refs.input در یک تمپلیت اکسپرسن دسترسی داشته باشید، در اولین رندر آن عدد خالی خواهد بود. این به این دلیل است که المنت تا پس از اولین رندر وجود ندارد!

<h2>
دستور Refs داخل v-for :
</h2>

> (به نسخه 3.2.25 یا بالاتر نیاز دارد)
 
هنگامی که ref در داخل v-for استفاده می شود، مقدار ref حاصل آرایه ای حاوی عناصر مربوطه خواهد بود:

```vue
<template>
  <ul>
    <li v-for="item in list" ref="items">
      {{ item }}
    </li>
  </ul>
</template>

<script>
export default {
  data() {
    return {
      list: [
        /* ... */
      ]
    }
  },
  mounted() {
    console.log(this.$refs.items)
  }
}
</script>
```
لازم به ذکر است که آرایه ref ترتیبی مشابه آرایه اولیه را تضمین نمی کند.

<h2>
تابع رفرنس (function ref) :
</h2>

 به جای یک کلید رشته ای، ref همچنین می تواند به یک تابع متصل شود، که در به روز رسانی هر مؤلفه فراخوانی می شود و انعطاف کاملی در مورد مکان ذخیره عنصر مرجع می دهد. تابع مرجع عنصر را به عنوان اولین آرگومان دریافت می کند:

```html
<input :ref="(el) => { /* assign el to a property or ref */ }">
```

توجه داشته باشید که ما از یک بایندینگ دینامیک :ref استفاده می کنیم تا بتوانیم به جای رشته ref، تابعی را به آن پاس دهیم. هنگامی که عنصر unmount شود، آرگومان null خواهد بود. البته می توانید از یک متد به جای تابع درون خطی استفاده کنید.


<h2>
استفاده از ref روی کامپوننت ها:
</h2>

برای این کار باید با کامپوننت ها آشنایی کامل داشته باشیم. می توانید از آن صرف نظر کنید و بعداً برگردید. ref را می توان روی کامپوننت فرزند نیز استفاده کرد. در این مورد رفرنس یک نمونه کامپوننت خواهد بود:

```vue
<template>
  <Child ref="child" />
</template>

<script>
import Child from './Child.vue'

export default {
  components: {
    Child
  },
  mounted() {
    // this.$refs.child will hold an instance of <Child />
  }
}
</script>
```

نمونه ای که به آن رفرنس داده ایم با این مؤلفه فرزند یکسان خواهد بود، به این معنی که مؤلفه والد به هر ویژگی و روش مؤلفه فرزند دسترسی کامل خواهد داشت. این باعث می‌شود که ایجاد جزئیات پیاده‌سازی کاملاً مرتبط بین والدین و فرزند آسان شود، بنابراین باید از ref های کامپوننتی فقط در مواقع ضروری استفاده شود - در بیشتر موارد، باید سعی کنید تعاملات والدین / فرزند را با استفاده از لوازم استاندارد پیاده‌سازی کنید و ابتدا رابط‌ها را منتشر کنید.

<h5>
از گزینه expose می توان برای محدود کردن دسترسی به نمونه فرزند استفاده کرد:
</h5>

```js
export default {
  expose: ['publicData', 'publicMethod'],
  data() {
    return {
      publicData: 'foo',
      privateData: 'bar'
    }
  },
  methods: {
    publicMethod() {
      /* ... */
    },
    privateMethod() {
      /* ... */
    }
  }
}
```
در مثال بالا، والدی که از طریق تمپلیت ref به این مؤلفه ارجاع می دهد، فقط می تواند به publicData و publicMethod دسترسی داشته باشد.


