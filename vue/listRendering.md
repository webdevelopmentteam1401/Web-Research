<div dir = "rtl">
<h1>
رندر کردن لیست:
</h1>

<h2>
دستور v-for:
</h2>

می توانیم از دستور v-for برای رندر لیستی از آیتم ها بر اساس یک آرایه استفاده کنیم. دستور v-for به یک سینتکس خاص به شکل آیتم در آیتم ها نیاز دارد، جایی که آیتم ها آرایه داده مبدا و آیتم نام مستعار عنصر آرایه ای است که در موارد زیر تکرار می شود:


```vue
<script>
export default {
    data() {
      return {
        items: [{ message: 'Foo' }, { message: 'Bar' }]
      }
    }
}
</script>
```
```vue
<li v-for="item in items">
  {{ item.message }}
</li>
```

در داخل اسکوپ v-for، عبارات تمپلیت به تمام پراپرتی های اسکوپ والد دسترسی دارند. علاوه بر این، v-for همچنین از نام مستعار اختیاری دوم برای ایندکس آیتم فعلی پشتیبانی می کند:

```vue
<script>
export default {
    data() {
      return {
        parentMessage: 'Parent',
        items: [{ message: 'Foo' }, { message: 'Bar' }]
      }
    }
}
</script>
```

```vue
<li v-for="(item, index) in items">
  {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```

توجه کنید که چگونه مقدار v-for با امضای تابع forEach callback مطابقت دارد. در واقع، می‌توانید از destructuring در مورد v-for، مشابه آرگومان‌های تابع destructuring استفاده کنید:

```vue
<li v-for="{ message } in items">
  {{ message }}
</li>
```
```vue
<!-- with index alias -->
<li v-for="({ message }, index) in items">
  {{ message }} {{ index }}
</li>
```

همچنین می‌توانید به‌جای in از on در شرط استفاده کنید تا به سینتکس جاوا اسکریپت برای ایتریتورها نزدیک‌تر باشد:

```vue
<div v-for="item of items"></div>
```
<h2>
متد v-for در آبجکت ها:
</h2>
شما همچنین می توانید از v-for برای ایتریت روی پراپرتی های یک شی استفاده کنید. ترتیب پیمایش بر اساس نتیجه فراخوانی Object.keys() روی شی خواهد بود:

```vue
<script>
export default {
  data() {
    return {
      myObject: {
        title: 'How to do lists in Vue',
        author: 'Jane Doe',
        publishedAt: '2016-04-10'
      }
    }
  }
}
</script>
```
```vue
<ul>
  <li v-for="value in myObject">
    {{ value }}
  </li>
</ul>
```

<h2>
بازه برای v-for:
</h2>

متد v-for همچنین می تواند یک عدد صحیح بگیرد. در این حالت الگو را چندین بار بر اساس محدوده 1...n تکرار می کند.

```vue
<span v-for="n in 10">{{ n }}</span>
```

<h2>
حفظ حالت با key:
</h2>
هنگامی که Vue لیستی از عناصر ارائه شده با v-for را ایتریت می کند، به طور پیش فرض از یک استراتژی "پچ درجا" استفاده می کند. اگر ترتیب اقلام داده تغییر کرده باشد، به جای جابجایی عناصر DOM برای مطابقت با ترتیب موارد، Vue هر عنصر را در جای خود پچ می کند و مطمئن می شود که آنچه را که باید در آن ایندکس خاص ارائه شود بازگردانده شود.
این حالت پیش‌فرض کارآمد است، اما فقط زمانی مناسب است که خروجی رندر فهرست شما به حالت مؤلفه فرزند یا وضعیت موقت DOM (مثلاً مقادیر ورودی فرم) متکی نباشد.
برای دادن راهنمایی به Vue به طوری که بتواند هویت هر گره را ردیابی کند و بنابراین از عناصر موجود استفاده مجدد و ترتیب مجدد دهد، باید یک ویژگی (key) منحصر به فرد برای هر مورد ارائه دهید:

```vue
<div v-for="item in items" :key="item.id">
  <!-- content -->
</div>
```

توصیه می‌شود هر زمان که ممکن است یک ویژگی کلیدی با v-for ارائه کنید، مگر اینکه محتوای DOM تکرار شده ساده باشد (یعنی شامل هیچ مؤلفه یا عناصر DOM حالتی نباشد)، یا عمداً برای افزایش عملکرد به رفتار پیش‌فرض تکیه کنید.
بایند کلید انتظار مقادیر اولیه را دارد - یعنی رشته ها و اعداد. از اشیاء به عنوان کلیدهای v-for استفاده نکنید.

<h2>
تشخیص تغییر آرایه:
</h2>

<p>
متد های جهشی:
</p>
Vue می‌تواند تشخیص دهد که چه زمانی روش‌های جهش آرایه واکنشی فراخوانی می‌شوند و به‌روزرسانی‌های لازم را آغاز می‌کنند. این روش های جهش عبارتند از:
<p>
•	push()<br>
•	pop()<br>
•	shift()<br>
•	unshift()<br>
•	splice()<br>
•	sort()<br>
•	reverse()<br>
</p>

<h2>
جایگزین کردن یک آرایه:
</h2>
روش‌های جایگزینی آرایع، همانطور که از نام آن پیداست، آرایه اصلی را که فراخوانی شده‌اند را تغییر می‌دهند. در مقایسه، روش های غیر جهشی نیز وجود دارد، به عنوان مثال. filter()، concat() و slice()، که آرایه اصلی را تغییر نمی دهند اما همیشه یک آرایه جدید را برمی گرداند. هنگام کار با روش‌های بدون جهش، باید آرایه قدیمی را با آرایه جدید جایگزین کنیم:

```JS
this.items = this.items.filter((item) => item.message.match(/Foo/))
```

ممکن است فکر کنید که این باعث می شود Vue،  DOM موجود را دور بریزد و کل لیست را دوباره رندر کند - خوشبختانه اینطور نیست. Vue برخی از الگوریتم های هوشمند را برای به حداکثر رساندن استفاده مجدد از عناصر DOM پیاده‌سازی می‌کند، بنابراین جایگزینی یک آرایه با آرایه دیگری حاوی اشیاء همپوشانی یک عملیات بسیار کارآمد است.

نمایش نتایج فیلتر/مرتب سازی:
گاهی اوقات می خواهیم یک نسخه فیلتر شده یا مرتب شده از یک آرایه را بدون تغییر یا تنظیم مجدد داده های اصلی نمایش دهیم. در این مورد، می توانید یک پراپرتی محاسبه شده ایجاد کنید که آرایه فیلتر شده یا مرتب شده را برمی گرداند.
برای مثال:

```vue
<script>
export default {
  data() {
    return {
      numbers: [1, 2, 3, 4, 5]
    }
  },
  computed: {
    evenNumbers() {
      return this.numbers.filter(n => n % 2 === 0)
    }
  }
}
</script>
```
```vue
<li v-for="n in evenNumbers">{{ n }}</li>
```

در شرایطی که پراپرتی های محاسبه شده قابل دسترسی نیست (به عنوان مثال در داخل حلقه های تو در تو v-for)، می توانید از روش استفاده کنید:

```vue
<script>
export default {
  data() {
    return {
      sets: [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
    }
  },
  methods: {
    even(numbers) {
      return numbers.filter(number => number % 2 === 0)
    }
  }
}
</script>
```
```vue
<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
```

مراقب ()reverse و sort() در یک پراپرتی محاسبه شده باشید! این دو روش آرایه اصلی را تغییر می‌دهند، که باید در دریافت‌کننده‌های محاسبه‌شده اجتناب شود. قبل از فراخوانی این متدها، یک کپی از آرایه اصلی ایجاد کنید:

```js
- return numbers.reverse()
+ return [...numbers].reverse()
```

</div>
